## Грамматика математических выражений:

Грамматика языка описана в **BNF** (Форма Бэкуса — Наура).

```
<expr> ::= <expr> + <term>
          | <expr> - <term>
          | <term>

<term> ::= <term> * <factor>
          | <term> / <factor>
          | <factor>

<factor> ::= ( <expr> ) - произвольная формула (expr)
          | Num            или число
```

## Принципы вычисления математических выражений:

Все формулы можно представить в виде *T1 + T2 + ... + Tn*

Где **Ti** - это формула вида *F1i * F2i * ... * Fmi*

Где **Fji** - это простейшая формула: единственное число или произвольная формула, заключенная в круглые скобки

Таким образом, все операции, которые имеют приоритет выше, будут выполняться первыми.
И только тогда, когда формула T1 будет вычислена, далее всегда идет операция сложения/вычитания.

---

**Таким образом, все формулы можно разделить на 3 вида:**
1) Простейшие формулы: **числа** и **формулы, заключенные в круглые скобки** | Например: *354*, *(17 + 3 - 18)*
2) Формулы, содержащие операции **умножения/деления** | Например: *18 * 2 * (13 + 5) * 7*
3) Формулы, содержащие операции **сложения/вычитания** | Например: *18 * 2 * (13 + 5) * 7 + 354 + (17 + 3 - 18) * (12 - 7)*

**Данные формулы в коде соответственно:**

1) **expression()** - функция вычисления значения формулы, содержащей операции сложения/вычитания
2) **term()** - функция вычисления значения формулы, содержащей операции умножения/деления
3) **factor()** - функция вычисления числа или произвольной формулы, заключенной в скобки

**Тогда вся формула может быть посчитана так:** ```expression(term(factor()))```

## Подробный разбор грамматики языка:

```
<expr> ::= <expr> + <term>
         | <expr> - <term>
         | <term>
```

Данная конструкция описывает **рекурсию**: *<expr>* будет заменяться на одно из 2-х первых выражений, пока не останется
всего один операнд, и тогда выражение будет выглядеть так: \<term\> +/- \<term\> +/- ... +/- \<term\>

```
<term> ::= <term> * <factor>
         | <term> / <factor>
         | <factor>
```

Та же самая ситуация, что и с *\<expr\>*: *\<term\>* будет заменяться, пока не останется всего один операнд (операндом
может быть и формула в скобках - *( \<expr\> )*, которое будет посчитано по аналогии с отальными произвольными
формулами)

```
<factor> ::= ( <expr> ) - произвольная формула в скобках
         | Num            или единственное число
```

## Terminator и Non-Terminator в BNF
**Non-Terminator** - это выражение, заключенное в ```<>```. Они могут заменяться на альтернативное выражение с правой
стороны от ```::=```

**Terminator** - не могут заменяться на альтернативные выражения. Обычно это токены, полученные от лексера

## Top-Down метод парсинга
В лексере используется *Top-Down метод парсинга*.

**Top-down parsing** - парсинг происходит сверху до низу. Именно это можно наблюдать в грамматике данного REPL'а:
Каждое выражение заменяется на альтернативное, продвигаясь каждый раз все ниже, пока не встретится terminator
(только один операнд)

## Левая рекурсия
При реализации REPL'а была использована **рекурсия с бэктрекингом** (recursion with backtracking).
Ведь, дойдя до терминатора, нам надо будет вернуться назад с вычисленным значением

**Например:**

Допустим, что наше текущее выражений имеет вид:
```
expr ::= <expr> + <factor>
```

Как бы это выглядело в коде? Примерно так:
```c++
int expr() {
    expr();
    factor();
}
```

Очевидно, что данная рекурсия никогда не закончится, и программа упадет. Поэтому, требуется использование *backtracking'а*
для того, чтобы вернуться назад и продолжить операцию сложения вычисленного левого значение с factor().

### Пример использования BNF и top-down parsing
Пусть есть выражение: ```3 * (4 + 2)```

Тогда **Parse tree** будет выглядеть так:
```
<expr> => <expr>
         => <term> *     <factor>
           => <factor>   |
             => Num (3)  |
                          => (<expr>)
                            => <expr>       + <term>
                              => <term>         |
                                => factor       |
                                  => Num (4)    |
                                                => <factor>
                                                  => Num (2)
```